项目架构：
	框架: Spring Boot 
	持久层框架 : Mybatis
	数据库连接池: Druid
	分页插件: Pagehelper
	缓存: Ehcache + Redis 
	权限管理: Shiro
	后台数据格式校验: Validation
	模板引擎: Freemarker
	消息中间件: Kafka + Zookeeper
	

权限插件（shiro）:
	可以实现应用中用户的权限控制，根据用户具有的权限以及角色，使用页面以及后台注解的方式控制具体按钮的权限
	1、登入认证与权鉴需要重写Realm	
	2、登入的缓存结合redis需要重新cache与session，这里注意存放时存入json格式未成功
	3、重写了UsernamePasswordToken 主要是给登入添加属性
	4、spring boot 中使用 ShiroConfig的方式配置shiro，包括重写的Realm、cache、session等
	
缓存组件（redis + Ehcache）:
	可以将用户增删改查的数据放入缓存中，提升访问速度，减轻服务器压力。本项目还未实现不同用户的cache同步问题，暂时不建议多用
	1、引入spring-boot-starter-data-redis jar包之后，容器中保存的是RedisCacheManager
	2、RedisCacheManager 帮我们创建RedisCache 来作为缓存组件，RedisCache通过操作redis缓存数据
	3、当k-v都是object时是利用序列化保存的，需要RedisConfig来配置序列化方式
	

多级缓存：
	一、对于实时性要求较高的数据，如例子中的商品库存，可以采用redis分布式缓存+mysql双写一致性保证方案。
		在本案例中使用内存队列的方式，对于这些实时性要求高的数据的访问进行封装之后，放入内存队列中的ArrayBlockingQueue中，使用专门的worker线程，排队操作，保证线程安全
		对于读请求，需要hang一定时间，进行从缓存读取，
	
 	二、对于实时性要求不高的数据，使用三级缓存，即： ehcache本地堆缓存 + redis分布式缓存 + nginx本地缓存
		本地堆缓存：防止redis的彻底崩溃，最为缓存的最后一道防线，避免数据库直接裸奔
	
		缓存数据生产策略：有数据发生变更  --> 发送消息到消息队列 --> 监听到有消息时，主动更新两级缓存（redis+ehcache）
	
		双层nginx策略：
		1、请求转发至ngnx分发层
		2、分发层nginx使用lua脚本，根据特定值（商品ID）通过一定算法，转发至某一个应用层nginx
		3、应用层nginx 收到请求后，使用lua脚本按一下步骤：
			（1）尝试获取nginx本地共享缓存，未获取到，执行下一步骤
			（2）将应用层转发过来的参数，通过http发送到后台接口获取到数据，将获取到的数据继续保存到nginx共享缓存中
			（3）将获取到的数据渲染到nginx本地保存的页面模板中
		4、后台供三级缓存访问的接口流程：
			（1）redis中获取数据，若获取不到，执行下一步骤
			（2）从ehcache中获取数据，若获取不到，执行下一步骤
			（3）从数据库获取数据，进行缓存重建（可能引起分布式缓存重建冲突问题）
			
		分布式缓存重建冲突问题：
			在分布式场景下，可能部署多实例在不同的机器上，这个时候通过应用层的nginx的请求可能被分发至不同机器上
			在高并发情况下，可能都会去重建缓存。这个时候就有可能出现冲突问题。
			解决方法：
				（1）可以通过算法将相同类型的请求发送到同一服务器
				（2）分布式锁
			
		分布式锁
			若有多台机器访问同一个共享资源，如果需要加锁，让多个分布式的机器在访问共享资源的时候串行起来
			那么这个时候，多个不同机器上的服务共享的锁，就是分布式锁。这是为了保证一个方法在高并发情况下的同一时间只能被同一个线程执行
			
		zookeeper分布式锁解决并发冲突方案：
			（1）变更缓存重建以及空缓存请求重建，更新redis之前，都需要对应的key（例：商品Id）的分布式锁
			（2）拿到分布式锁之后，需要根据时间版本去比较，如果自己的版本新于redis中的版本，那么就更新，否则不更新
			（3）如果拿不到分布式锁，那么就等待，不断轮询等待，直到自己获得分布式锁	
		zookeeper分布式锁：
			（1）该项目中用到的锁的方式：
				zk 通过创建一个临时唯一的node 给一个商品Id（例）加锁，如果其他请求再要创建相同的临时node，
				就会报错NodeExistsException。所以说上锁，其实就是去创建某个商品id（例）对应的一个临时node
				创建成功就说明成功加锁了，此时就去执行对应的reids数据操作
				创建失败就说明别人已经拿到锁了，那么就不断的等待，直到可以获得锁
				释放即删除node
			
	三、大型缓存全量更新 即：将大量数据放在一个json中存入redis缓存
		问题： 1：网络资源消耗大
		 	 2：每次对redis都存取大数据，对redis压力较大
		 	 3：redis的性能和吞吐量 与 数据的大小有关系，如果数据越大，redis的吞吐量会急剧下降
		 
		缓存纬度化解决方案：将大量数据进行切割成不同的纬度，进行存储
		 
	
四、单例模式静态内部类为什么能保证线程安全：
	利用了Java中类的静态变量的唯一性这一特性 
	
			
	
